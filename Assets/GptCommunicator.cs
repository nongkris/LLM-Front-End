using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Networking;

/// <summary>
/// Communicates with GPT and illicits text responses from given prompts.
/// </summary>
public class GptCommunicator : MonoBehaviour
{
    [System.Serializable]
    public class Message
    {
        public string role;
        public string content;
    }

    [System.Serializable]
    public class RequestBody
    {
        public string model;
        public Message[] messages;
        public double temperature;
        public double presence_penalty;
        public double frequency_penalty;
    }

    [System.Serializable]
    public class Choice
    {
        public int index;
        public Message message;
        public string finish_reason;
    }

    [System.Serializable]
    public class Usage
    {
        public int prompt_tokens;
        public int completion_tokens;
        public int total_tokens;
    }

    [System.Serializable]
    public class Response
    {
        public string id;
        public string object_name;
        public int created;
        public string model;
        public Choice[] choices;
        public Usage usage;
    }

    public class QueuePrompt
    {
        string prompt;
        Character caller;
        ResponseReceived callback;
    }

    [Tooltip("Enter your OpenAI API key here.")]
    [SerializeField] private string mApiKey = "YOUR API KEY HERE";

    [Tooltip("Open AI competions URL. Probably shouldn't be changed.")]
    [SerializeField] private string mUrl = 
        "https://api.openai.com/v1/chat/completions";

    [Tooltip("Open AI model to generate responses from.")]
    [SerializeField] private string mModel = "gpt-4";

    [Tooltip("How often in seconds to make a request of the Open AI API.")]
    [SerializeField] float mRateLimit = 3.0f;

    [Tooltip("Turns GPT response requests on/off for debugging.")]
    [SerializeField] bool mSendRequests = true;

    /// <summary>
    /// Time of last request made of Open AI API.
    /// </summary>
    private float mLastRequestTime = 0;

    /// <summary>
    /// Delegate for callbacks to be executed upon receipt of a response from 
    /// Open AI API.
    /// </summary>
    /// <param name="received">
    /// Text response generated by Open AI model.
    /// </param>
    public delegate void ResponseReceived(string received);

    /// <summary>
    /// Requests a statement to be made by Character from GPT in reply to 
    /// an ongoing conversation.
    /// </summary>
    /// <param name="prompt">
    /// Conversation GPT should generate a reply to.
    /// </param>
    /// <param name="callback">
    /// Method to execute once reply has been received from GPT.
    /// </param>
    public void RequestConversationalReply
        (string prompt, Character caller, ResponseReceived callback)
    {
        string replyPrompt = $"{prompt} {Defines.REPLY_INSTRUCT}" +
            $"{Defines.RESPONSE_CHECK}{Defines.RESPONSE_DENY}";
        StartCoroutine(PromptGpt(replyPrompt, caller, callback));
    }

    public void RequestVisualQueuePrompt
        (string prompt, Character caller, ResponseReceived callback)
    {
        string replyPrompt = $"{Defines.VIS_ASSESS_HEAD} {prompt}" +
            $" {Defines.VIS_ASSESS_SAY} {Defines.RESPONSE_CHECK}" +
            $"{Defines.RESPONSE_DENY}";
        StartCoroutine(PromptGpt(replyPrompt, caller, callback));
    }

    /// <summary>
    /// Requests instructions on what to do from GPT based on a text 
    /// description of a Character's current state in the game.
    /// </summary>
    /// <param name="prompt">
    /// Description of character's current state.
    /// </param>
    /// <param name="callback">
    /// Method to execute upon receipt of instructions from GPT.
    /// </param>
    public void RequestReactionInstructions
        (string prompt, Character caller, ResponseReceived callback)
    {
        string spokenReplyPrompt = $"{prompt} {Defines.REACT_INSTRUCT}";
        StartCoroutine(PromptGpt(spokenReplyPrompt, caller, callback));
    }

    /// <summary>
    /// Prompts Open AI GPT model.
    /// </summary>
    /// <param name="prompt">
    /// Text prompt for GPT.
    /// </param>
    /// <param name="callback">
    /// Method to execute upon receipt of response from GPT.
    /// </param>
    /// <returns></returns>
    IEnumerator PromptGpt
        (string prompt, Character caller, ResponseReceived callback)
    {
        if (caller.Verbose)
            Debug.Log($"Sending reply request for prompt:\n{prompt}.");
        if (mSendRequests)
        {
            // Current game time.
            float time = Time.realtimeSinceStartup;

            // Difference between current time and the last  request.
            float delta = time - mLastRequestTime;

            // How long to wait before making another request.
            float waitSeconds = delta >= mRateLimit ? 0 : mRateLimit - delta;

            yield return new WaitForSeconds(waitSeconds);
            UnityWebRequest www = new UnityWebRequest(mUrl, "POST");
            www.SetRequestHeader("Content-Type", "application/json");
            www.SetRequestHeader("Authorization", $"Bearer {mApiKey}");
            Message message = new Message
            {
                role = "user",
                content = prompt
            };
            caller.Messages.Add(message);
            RequestBody body = new RequestBody
            {
                model = mModel,
                messages = caller.Messages.ToArray(),
                temperature = caller.Temperature,
                presence_penalty = caller.PresencePenalty,
                frequency_penalty = caller.FrequencyPenalty
            };
            string bodyJson = JsonUtility.ToJson(body);
            byte[] bodyRaw = new System.Text.UTF8Encoding().GetBytes(bodyJson);
            www.uploadHandler = new UploadHandlerRaw(bodyRaw);
            DownloadHandlerBuffer dH = new DownloadHandlerBuffer();
            www.downloadHandler = dH;
            yield return www.SendWebRequest();
            if (www.result == UnityWebRequest.Result.Success)
            {
                Response response =
                    JsonUtility.FromJson<Response>(www.downloadHandler.text);
                string responseText = response.choices[0].message.content;
                if (!responseText.Contains(Defines.RESPONSE_DENY))
                {
                    caller.Messages.Add(
                        new Message { role = "assistant", content = responseText }
                    );
                    callback?.Invoke(responseText.Replace("\"", string.Empty));
                }
                else
                    Debug.Log($"Got denial string \"{Defines.RESPONSE_DENY}\"" +
                        $" from prompt:\n\"{prompt}\"");
            }
            else
            {
                Debug.Log($"Requester Error: {www.error}");
            }
            mLastRequestTime = Time.realtimeSinceStartup;
        }
    }
}
